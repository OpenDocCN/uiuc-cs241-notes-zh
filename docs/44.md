# 死锁复习题

> 原文：<https://github.com/angrave/SystemProgramming/wiki/Deadlock-Review-Questions>

## 话题

Coffman条件资源分配图用餐哲学家

*   DP解决方案失败
*   活锁DP解决方案
*   工作DP解决方案：优势/缺点

## 问题

*   什么是科夫曼条件？
*   每个科夫曼条件意味着什么？ （例如，你能提供每个的定义）
*   给出一个真实的例子，依次打破每个Coffman条件。需要考虑的情况：画家，油漆，油漆刷等。您如何确保工作完成？
*   能够识别Dining Philosophers代码何时导致死锁（或不）。例如，如果您看到以下代码片段不满足Coffman条件？

```c
// Get both locks or none.
pthread_mutex_lock( a );
if( pthread_mutex_trylock( b ) ) { /*failed*/
   pthread_mutex_unlock( a );
   ...
}
```

*   如果一个线程调用

```c
  pthread_mutex_lock(m1) // success
  pthread_mutex_lock(m2) // blocks
```

和另一个线程调用

```c
  pthread_mutex_lock(m2) // success
  pthread_mutex_lock(m1) // blocks
```

会发生什么？为什么？如果第三个线程调用`pthread_mutex_lock(m1)`会发生什么？

*   有多少进程被阻止？像往常一样，假设一个流程能够获得下面列出的所有资源，就能够完成。
    *   P1获得R1
    *   P2获得R2
    *   P1收购R3
    *   P2等待R3
    *   P3收购R5
    *   P1等待R4
    *   P3等待R1
    *   P4等待R5
    *   P5等待R1

（画出资源图！）