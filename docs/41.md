# 死锁，第 1 部分：资源分配图

> 原文：<https://github.com/angrave/SystemProgramming/wiki/Deadlock%2C-Part-1%3A-Resource-Allocation-Graph>

## 什么是资源分配图？

资源分配图跟踪哪个进程持有哪个资源以及哪个进程正在等待特定类型的资源。它是一个非常强大而简单的工具，用于说明交互过程如何解锁。如果进程是 _ 使用 _ 资源，则从资源节点向进程节点绘制箭头。如果进程是 _ 请求 _ 资源，则从进程节点向资源节点绘制箭头。

如果资源分配图中存在循环，并且循环中的每个资源仅提供一个实例，则进程将死锁。例如，如果进程 1 保存资源 A，则进程 2 保存资源 B，进程 1 等待 B，进程 2 等待 A，然后进程 1 和进程 2 将被死锁。

这是另一个示例，显示进程 1 和 2 获取资源 1 和 2，而进程 3 正在等待获取两个资源。在这个例子中没有死锁，因为没有循环依赖。

![ResourceAllocationGraph-Ex1.png](img/1e88c8266f91417008f275b2eec36df7.jpg)

## 僵局！

很多时候，我们不知道可以获取资源的具体顺序，因此我们可以绘制图表。

![](img/27f5f2c018c60372297e6cf5790934bc.jpg)

作为一种可能性矩阵。然后我们可以绘制箭头，看看是否有导致我们陷入僵局的定向版本。

![RAG Deadlock](img/2d19ee5fcdb522a5a43850cd1746a70a.jpg)

请考虑以下资源分配图（假设进程要求对文件进行独占访问）。如果你有一堆进程正在运行并且它们请求资源并且操作系统最终处于这种状态，那么你就会陷入僵局！您可能看不到这一点，因为操作系统可能* _ 抢占 _ 某些进程打破了循环，但仍有一个变化，您的三个孤独进程可能会死锁。您还可以使用`make`和规则依赖关系（例如我们的 parmake MP）制作这些图形。

![](img/bfa1f1caf816f2b844ae5b14da43f11b.svg)